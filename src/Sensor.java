
import java.util.*;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.text.Text;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;


/**
 * @author Miralda Rodney
 * 
 * @version 1.0
 * 
 * 
 * In this Sensor Class, the sensor will determine whether or not 
 * there is a point within its range that is a "recognized" reference point.
 * When a point is detected, robots' location and the estimated reference point 
 * location is saved in a file.
 * 
 * The Sensor Class will perform calculation to determine the distance between 
 * itself (robot) and the points around it. It will "track" its location in relation
 * to the points around it so that the Robot can determine it's own x and y location to 
 * figure out where it began on the "field".
 *
 **/

public class Sensor {

	/**
	 * This is the default constructor for the sensor method.
	 */
	public Sensor(){
	}

	/**
	 * The detectPoints method uses the static array of randomly generated 
	 * reference points from the Map class. The sensor will check the area 
	 * in its scope (defined by the user) to figure out if there are any 
	 * points in the vicinity. When a point is detected, the estimated location
	 * of the point is saved formatted in a file.
	 *
	 *
	 * @param rangeOfSensor - user defined sensor range 
	 * @param robotX - the robot's x location at each movement
	 * @param robotY - the robot's y location at each movement
	 * @param sensorError - user defined error in sensor
	 * 
	 * 
	 * @exception IOException is thrown if the file is not found or if there
	 * is a problem writing to the file.
	 **/
	public void detectPoints(double rangeOfSensor, double robotX, double robotY, double sensorError) throws IOException{

		/**
		 * loop counters to use in for loops in order
		 * to access points in 2D array of points.
		 */
		int i = 0;
		int j = 0;

		/**
		 * creating a local array that points to the 
		 * array of reference points generated by the
		 * Map class.
		 */
		int[][] refPointLoc = Map.refPoints;

		/**variables to represent the sensor range based
		 * on the user defined scope and the robots' 
		 * current  X and Y location
		 */
		double rangeSensorX = rangeOfSensor + robotX;
		double rangeSensorY = rangeOfSensor + robotY;

		/**
		 * variables to hold the sensed reference point
		 * x- and y-values with accounted error.
		 */
		double pointDetectedX = 0.0;
		double pointDetectedY = 0.0;

		/**
		 * variables to hold the error account for based on 
		 * where the point is in the robots' range. Closer means
		 * less error, farther means full error as defined by user.
		 */
		double errorInX = 0.0;
		double errorInY = 0.0;

		/**
		 * loop to access the information in the reference point
		 * array. Based on the region where the reference point is 
		 * sensed, the error will be the (1) user-defined max at the
		 * edge, (2) two-thirds of the error in the midpoint region, 
		 * and (3) one-third of the error in the inner ring and right
		 * on top of a point.
		 */
		for(i = 0; i < refPointLoc.length -1; i++){

			for(j = 0; j < refPointLoc[i].length; j++){

				if( (refPointLoc[i][j] > ((2/3)*rangeSensorX) && refPointLoc[i][j] <= (rangeSensorX))  && (refPointLoc[i+1][j] > ((2/3)*rangeSensorY) && refPointLoc[i+1][j] <= (rangeSensorY)) ){

					errorInX = ( (sensorError/100)*refPointLoc[i][j] );
					pointDetectedX = refPointLoc[i][j] + errorInX;
					errorInY = ( (sensorError/100)*refPointLoc[i+1][j] );
					pointDetectedY = refPointLoc[i+1][j] + errorInY;
					
					saveToFile(robotX, robotY, pointDetectedX, pointDetectedY);
				}
				if(refPointLoc[i][j] <= ((1/3)*rangeSensorX) && refPointLoc[i+1][j] <= ((1/3)*rangeSensorY)){

					errorInX = ( ((0.3)*sensorError/100)*refPointLoc[i][j] );
					pointDetectedX = refPointLoc[i][j] + errorInX;
					errorInY = ( ((0.3)*sensorError/100)*refPointLoc[i+1][j] );
					pointDetectedY = refPointLoc[i+1][j] + errorInY;
					
					saveToFile(robotX, robotY, pointDetectedX, pointDetectedY);
				}
				if( (refPointLoc[i][j] > ((1/3)*rangeSensorX) && refPointLoc[i][j] <= ((2/3)*rangeSensorX)) && (refPointLoc[i+1][j] > ((1/3)*rangeSensorY) && refPointLoc[i+1][j] <= ((2/3)*rangeSensorY)) ){

					errorInX = ( ((0.6)*sensorError/100)*refPointLoc[i][j] );
					pointDetectedX = refPointLoc[i][j] + errorInX;
					errorInY = ( ((0.6)*sensorError/100)*refPointLoc[i+1][j] );
					pointDetectedY = refPointLoc[i+1][j] + errorInY;
					
					saveToFile(robotX, robotY, pointDetectedX, pointDetectedY);
				}
				
				}
			}
		}
	
	/**
	 * This will save the points formatted to a file, will
	 * probably differentiate the points detected in each run 
	 * by a space of something, hopefully so I can use a 
	 * switch statement.
	 * 
	 * @param rx
	 * @param ry
	 * @param sx
	 * @param sy
	 */
	public void saveToFile(double rx, double ry, double sx, double sy){
		
		try{
			File saveDetectedPoints = new File("DetectedPoints.txt");
			saveDetectedPoints.createNewFile();
			BufferedWriter bWSavePoints = new BufferedWriter(new FileWriter(saveDetectedPoints, true));
			bWSavePoints.write(rx + "," + ry + "," + sx + "," + sy + "\n");
			bWSavePoints.newLine();
			bWSavePoints.close();
		}
		catch (IOException iOEx1){
			Stage errorInSensingMessage = new Stage();
			errorInSensingMessage.initStyle(StageStyle.UNIFIED);
			Scene scene = new Scene(new Group(new Text(25, 25, "Erorr! The Sensor has crashed!! ")));
			errorInSensingMessage.setScene(scene);
			errorInSensingMessage.show();
		}	
	}

/**
 * The distanceBetweenPoints method will get the 
 * 
 * @exception IOException is thrown
 */
public void distanceBetweenPoints() throws IOException{

	//this method will read the detectedPoints file to figure out the
	//distance between every two point, so 1 and 2, 2 and 3, etc.

	double distanceOfRef1FromRobot = 0.0;

	double distanceOfRef2FromRobot = 0.0;

	double distanceBetween2RefPoints = 0.0;

	double radiansOfAngle = 0.0;

	double angleOfRobotAndTwoPoints = 0.0;

	try{

		Scanner readFile = new Scanner(new File("detectedPoints.txt"));

		readFile.useDelimiter(",");

		double robotsX1, robotsY1, refPointX1, refPointY1, robotsX2,
		robotsY2, refPointX2, refPointY2;

		while(readFile.next() != null){

			robotsX1 = readFile.nextDouble();

			robotsY1 = readFile.nextDouble();

			refPointX1 = readFile.nextDouble();

			refPointY1 = readFile.nextDouble();

			readFile.nextLine();

			robotsX2 = readFile.nextDouble();

			robotsY2 = readFile.nextDouble();

			refPointX2 = readFile.nextDouble();

			refPointY2 = readFile.nextDouble();


			if(robotsX1 == robotsX2 && robotsY1 == robotsY2){

				distanceOfRef1FromRobot = Math.sqrt(Math.pow((robotsX1 - refPointX1), 2) + Math.pow((robotsY1 - refPointY1), 2));

				distanceOfRef2FromRobot = Math.sqrt(Math.pow((robotsX2 - refPointX2), 2) + Math.pow((robotsY2 - refPointY2), 2));

				distanceBetween2RefPoints = Math.sqrt(Math.pow((refPointX1 - refPointX2), 2) + Math.pow((refPointY1 - refPointY2), 2));

				radiansOfAngle = Math.acos((Math.pow(distanceOfRef1FromRobot, 2) + Math.pow(distanceOfRef2FromRobot, 2) - Math.pow(distanceBetween2RefPoints, 2))/(2*distanceOfRef1FromRobot*distanceOfRef2FromRobot));

				angleOfRobotAndTwoPoints = Math.toDegrees(radiansOfAngle);

			}
			else{

				distanceOfRef1FromRobot = Math.sqrt(Math.pow((robotsX1-refPointX1), 2) + Math.pow((robotsX2-refPointX2), 2));


			}

			readFile.close();		
		}
	}
	catch(IOException iOEx2){

		iOEx2.printStackTrace();
	}	
}
}